я не знаю английский, серьёзно..

Проект имеет кучу классов, потенциально - очень много
Рассмотрим идею.

Создадим класс войны, пусть он занимается битвой двух персонажей. Т.к. персонажей много, то удобно использовать шаблоны для этого класса, пусть он принимает себе двух бойцов и обеспечивает интерфейс битвы. 
- можем ли мы продолжать (живы ли оба)
- кто победил или ничья?
- установка очередного хода (блоки, удары каждого)
- сделать ход (пусть бьються)

Тогда сделаем игровой цикл, пример можно видеть в main, таким образом будут реализованы битвы, хотя и это можно было бы запихать в класс войны, но тогда менее просто манипулировать с состояниями, а это возможно нужно для поддержки нескольких одновременных битв при потоках, что удовнее сделать внутри потока таким циклом, с отслеживанием нужного (с нынешним функционалом). При сильном увеличении нагруженности - имеет смысл.

Итак, класс войный есть, нужны персонажи. Они у нас обладают одинакоыми стилями боя, а так же некоторыми своми особенностями. Имеет смысл сделать класс прородитель, от которого унаследуем все. Туда имеет место положить описание:
- все тривида ударов
- структура "хп, стан"
- структура "что блокируем, как ударяем"

первое реализовано посредством std::function, подгружаемых потенциальным разработчиком, я ставил задачу реализовать шаблон для программиста

второе очевидно.
третье описывает состояние хода, удобно представлять персонажа как семантически "динамический класс"

Ззамечание: так же использован файл констант, потому что мне так нравится, try catch не за горами, наверно, нужно прочувствовать

Рассмотрим персонажей, они - наследники класса being
у каждого пусть будет своя отличительная черта, конкретно взяты рыцарь и фея, у феи яд, у рыцаря броня. 

Для феи удобно представлять яд, как "сколько яд ещё действует на противника?", а для рыцаря "сколько у меня ещё брони?"

Стандартизируем функции атак:
	- функция аттаки принимает being врага
	- возвращает состояние (хп, стан) врага после аттаки, не меня врага ныне
	- функция может менять состояние особенных характеристик, предполагается, что на них нельзя действовать другим (расширяемо до обратного посредством другой стандартизации)
	- функция не меняет хп (обратное расширяемо), т.е. играем без регена

В такой нотации определим удары так:
	копируем состояния обоих, взаимодействуем копиями в функцию аттаки, получаем итоговые состояния, присваиваем их бойцам

Особенности реализации:
	- сеттеры и геттеры в being
	- funcType
	- наследники приводится типом к своему родителю, чтобы обработаться в функции, такое приведение всегда безопасно, всё отлично
	- функции в интерфейсе не умеют номеров, имеют названия, но реализовано внутри через номера, ибо так удобно проверять блоки