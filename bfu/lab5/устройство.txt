Потоки - это по взрослому (с)

Проект представляют 4 файла, 2 класса, потокобезопасный стек и защитник потока. Защитник сделан конкретно под задачу через std::function

Имеем 3 файла, в каждом число n - количество операций, далее сами операции. 
Логи будем вести так:
	- при запросе top будем выводить какой поток что вытаскивает, притом если пусто, предпалается выводить нейтральный элемент, либо соотвествующее сообщение (легко расширяемо)
	- заведём mutex для вывода в консоль

После отработки всех потоков выводится состояние стека "сверху - вниз"

рассмотрим потокобезопаный стек:

По заданию нужно использовать умные указатели, <стек>, class, заведём для этого template для стека, а элементом стека будет указатель на данные

Добавим в стек mutex, сделаем его mutable, т.к. пользователь не взаимодействует с мутЕхом, это нужно для разработчика класса, а значит, чтобы сохранить константный стиль, добавим это слово.

Т.к. у нас template, то, чтобы не возиться с экземплярами, вся реализация методов снесена в hpp после класса. Хотя можно это обойти кое-как через создание объекта с нужной сигнатурой и убрать реализацию в cpp, однако не это цель лабораторной

Деструктор сделан по принципу "всё вытащим. всё удалим". Мы можем этого не делать, если у класса предположительно есть деструктор, однако если он там не очень, то это покроект проблемы.

мутЕх будем использовать через lock_guard, потому что мне понравилась идея "в конструктор лок, в деструктор унлок", это эстетично (имхо)

Push хотелось сделать через &&, но т.к. нам всегда перевыделять память внутри из-за указателей, посчитал это не принципиальным

top вытаскивает сразу элемент, не указатель, ибо возможно, что другой поток потом сделает невалидолом этот указатель